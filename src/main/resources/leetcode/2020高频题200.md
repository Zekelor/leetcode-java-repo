## 经典题目

### LC 最大子序和

### 合并两个有序数组

### 买卖股票的最佳时机

### 验证回文串

### 二叉树的层序遍历

### 复制带随机指针的链表

### LRU缓存机制

### 岛屿数量

### 接雨水

### 最小覆盖子串

## 数组

### 寻找两个正序数组的中位数

### 盛最多水的容器

### 三数之和

### 下一个排列

### 搜索旋转排序数组

### 在排序数组中查找元素的第一个和最后一个位置

### 螺旋矩阵

### 合并区间

### 除自身以外数组的乘积

### 最后一块石头的重量Ⅱ

## 字符串

### 整数转换英文表示

### 字符串相加

### 验证回文字符串Ⅱ

### 最常见的单词

### 重新排列日志文件

## 链表

### 两数相加

### LC03-无重复字符的最长子串（滑动窗口）

解题思路

__滑动窗口__

* 将符合条件的字符串作为一个窗口，遍历走完整个字符串;
* 初始化 `int left =0 ` 作为左侧的下标；
* 初始化 `int max = 0 ` 作为窗口的最大长度；
* 当符合遇到重复的字符时，窗口变化，形成新的窗口,此时 left -1，移出队列；

```java
public class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> compareMap = new HashMap<>();

        int left = 0;
        int max = 0;

        for (int i = 0; i < s.length(); i++) {

            if (compareMap.containsKey(s.charAt(i))) {
                left = Math.max(left, s.charAt(i) + 1);
            }

            map.put(s.charAt(i), i);

            max = Math.max(max, i - left + 1);
        }

        return max;
    }
}
```

### 删除链表的倒数第N个节点

### 合并两个有序链表

### 反转链表

## 堆与栈

### 有效的括号

### 会议室Ⅱ

### 前K个高频单词

### 移除无效的括号

## 哈希表

### 两数之和

### 字母异位词分组

### 和为K的子数组

### 验证外星语词典

## 树

### 验证二叉搜索数

### 二叉树中的最大路径和

### 二叉树的右视图

### 二叉树的最近公共祖先

### 二叉树的直径

### 另一个树的子树

## 分治算法

### 合并K个排序链表

### Lc215-数组中的第K个最大元素

__解题思路__:

* 本题目的是考察排序，将无序的数组排序后输出第K个元素；

* 关于快速排序，网上有很多的方法，关于快速排序原理可查看 [快速排序原理图解][quicksort]
* Java版的参考 [快速排序的实现][java-quicksort]

[quicksort]: https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html

[java-quicksort]: https://www.anvilliu.com/2021/03/08/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BC%98%E5%8C%96/#%E4%B8%89%E5%90%91%E5%88%87%E5%88%86

```java
public class Solution {

    /**
     * 入口函数
     * @param nums
     * @param k
     * @return
     */
    public int findKthLargest(int[] nums, int k) {

    }

    public void quickSort(int[] nums, int left, int right) {
        if (left > right) {
            return;
        }

        int low = left;

        int high = right;

        int k = (int) (Math.random() * (right - left + 1)) + left;

        int pivot = nums[left];

        swap(nums, left, k);

        while (left < right) {

            while (left < right && nums[high] >= pivot) {
                high--;
            }

            while (left < right && nums[low] <= pivot) {
                low++;
            }

            swap(nums, low, high);
        }

        swap(nums, left, high);
		
        quickSort(nums,left,low-1);

        quickSort(nums, low + 1, right);

    }

    public void swap(int[] nums, int i, int k) {
        int temp = nums[i];
        nums[i] = nums[k];
        nums[k] = temp;
    }

}

```

### 搜索二维矩阵Ⅱ

### 最接近原点的K个点

## 回溯算法

### 电话号码的字母组合

### 括号生成

### 全排列

### 单词搜索

## 图论

### 单词接龙

### 火星词典

### 删除无效的括号

### 腐烂的橘子

### 查找集群内的 [关键连接]

## 动态规划

### 最长回文子串

### 最小路径和

### 编辑距离

### 单词拆分

### 零钱兑换

## 数学

### 整数反转

### 字符串转换整数(atoi)

### 二进制求和

### 快乐数

## 设计

### 数据流的中位数

### 二叉树的序列化和反序列化

### 常数时间插入、删除和获取随机元素